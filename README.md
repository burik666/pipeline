<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# pipeline

```go
import "github.com/burik666/pipeline"
```

## Index

- [func Do\[T any\]\(in T, stages ...StageFn\[T\]\) \(T, error\)](<#Do>)
- [func Run\[T any\]\(stages ...StageFn\[T\]\) \(T, error\)](<#Run>)
- [type OptFn](<#OptFn>)
  - [func WithName\(name string\) OptFn](<#WithName>)
- [type Opts](<#Opts>)
  - [func \(o Opts\) Name\(\) string](<#Opts.Name>)
- [type Pipeline](<#Pipeline>)
  - [func New\[T any\]\(stages ...Stage\[T\]\) Pipeline\[T\]](<#New>)
  - [func \(p \*Pipeline\[T\]\) Do\(in T\) \(T, error\)](<#Pipeline[T].Do>)
  - [func \(p \*Pipeline\[T\]\) Middleware\(mw func\(T, func\(T\) \(T, error\), Opts\) \(T, error\)\)](<#Pipeline[T].Middleware>)
  - [func \(p \*Pipeline\[T\]\) Run\(\) \(T, error\)](<#Pipeline[T].Run>)
- [type Stage](<#Stage>)
  - [func NewProducer\[T any\]\(fn func\(func\(T\) \(T, error\)\) error, opts ...OptFn\) Stage\[T\]](<#NewProducer>)
  - [func NewSimpleStage\[T any\]\(fn func\(T\) \(T, error\), opts ...OptFn\) Stage\[T\]](<#NewSimpleStage>)
  - [func NewStage\[T any\]\(fn StageFn\[T\], opts ...OptFn\) Stage\[T\]](<#NewStage>)
- [type StageFn](<#StageFn>)


<a name="Do"></a>
## func Do

```go
func Do[T any](in T, stages ...StageFn[T]) (T, error)
```

Do creates pipline and runs the pipeline with the given input and returns the result.

<a name="Run"></a>
## func Run

```go
func Run[T any](stages ...StageFn[T]) (T, error)
```

Run creates pipline and runs the pipeline with default value input.

<a name="OptFn"></a>
## type OptFn

OptFn represents a function that applies an option to the value.

```go
type OptFn = func(*Opts)
```

<a name="WithName"></a>
### func WithName

```go
func WithName(name string) OptFn
```

WithName sets the name of the pipeline stage.

<a name="Opts"></a>
## type Opts

Opts represents the options for a pipeline stage.

```go
type Opts struct {
    // contains filtered or unexported fields
}
```

<a name="Opts.Name"></a>
### func \(Opts\) Name

```go
func (o Opts) Name() string
```

Name returns the name of the pipeline stage.

<a name="Pipeline"></a>
## type Pipeline

Pipeline is a sequence of stages that process some data.

```go
type Pipeline[T any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/burik666/pipeline"
)

func main() {
	// Define a stage that increments the input by 1
	stageInc := func(in int, next func(int) (int, error)) (int, error) {
		return next(in + 1)
	}

	// Create a new pipeline with two increment stages
	p := pipeline.New(
		pipeline.NewStage(stageInc),
		pipeline.NewStage(stageInc),
	)

	// Run the pipeline with an initial value of 0
	res, err := p.Do(0)
	if err != nil {
		panic(err)
	}

	fmt.Println(res)
}
```

#### Output

```
2
```

</p>
</details>

<details><summary>Example (Producer)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/burik666/pipeline"
)

func main() {
	// Define a producer that generates numbers from 0 to 4
	producer := func(next func(int) (int, error)) error {
		for i := 0; i < 5; i++ {
			res, err := next(i)
			if err != nil {
				return err
			}

			fmt.Println(res)
		}

		return nil
	}

	// Define a stage that multiplies the input by 2
	stageMul2 := func(in int, next func(int) (int, error)) (int, error) {
		return next(in * 2)
	}

	// Create a new pipeline with a producer and a stage
	p := pipeline.New(
		pipeline.NewProducer(producer),
		pipeline.NewStage(stageMul2),
	)

	// Run the pipeline
	_, err := p.Run()
	if err != nil {
		panic(err)
	}
}
```

#### Output

```
0
2
4
6
8
```

</p>
</details>

<a name="New"></a>
### func New

```go
func New[T any](stages ...Stage[T]) Pipeline[T]
```

New creates a new pipeline with the given stages.

<a name="Pipeline[T].Do"></a>
### func \(\*Pipeline\[T\]\) Do

```go
func (p *Pipeline[T]) Do(in T) (T, error)
```

Do runs the pipeline with the given input and returns the result.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/burik666/pipeline"
)

func main() {
	// Define a stage that increments the input by 1
	stageInc := func(in int, next func(int) (int, error)) (int, error) {
		return next(in + 1)
	}

	// Run the pipeline with two increment stages
	res, err := pipeline.Do(
		5,
		stageInc,
		stageInc,
	)
	if err != nil {
		panic(err)
	}

	fmt.Println(res)
}
```

#### Output

```
7
```

</p>
</details>

<a name="Pipeline[T].Middleware"></a>
### func \(\*Pipeline\[T\]\) Middleware

```go
func (p *Pipeline[T]) Middleware(mw func(T, func(T) (T, error), Opts) (T, error))
```

Middleware adds middleware to the pipeline. The middleware is applied to each stage in the pipeline. The middleware function is called with the input, the next function, and the stage options.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/burik666/pipeline"
)

func main() {
	// Define a stage that increments the input by 1
	stageInc := func(in int, next func(int) (int, error)) (int, error) {
		return next(in + 1)
	}

	// Create a new pipeline with two increment stages
	p := pipeline.New(
		pipeline.NewStage(stageInc, pipeline.WithName("stage1")),
		pipeline.NewStage(stageInc, pipeline.WithName("stage2")),
	)

	// Add a middleware that logs the stage name before and after execution
	p.Middleware(func(in int, next func(int) (int, error), opts pipeline.Opts) (int, error) {
		fmt.Printf("pre: %s\n", opts.Name())

		v, err := next(in)

		fmt.Printf("post: %s\n", opts.Name())

		return v, err
	})

	// Run the pipeline with an initial value of 0
	res, err := p.Do(0)
	if err != nil {
		panic(err)
	}

	fmt.Println(res)
}
```

#### Output

```
pre: stage1
pre: stage2
post: stage2
post: stage1
2
```

</p>
</details>

<a name="Pipeline[T].Run"></a>
### func \(\*Pipeline\[T\]\) Run

```go
func (p *Pipeline[T]) Run() (T, error)
```

Run runs the pipeline with default value input.

<a name="Stage"></a>
## type Stage

Stage represents a stage in the pipeline.

```go
type Stage[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewProducer"></a>
### func NewProducer

```go
func NewProducer[T any](fn func(func(T) (T, error)) error, opts ...OptFn) Stage[T]
```

NewProducer creates a new producer stage. Producer is the stage that only produces data.

<a name="NewSimpleStage"></a>
### func NewSimpleStage

```go
func NewSimpleStage[T any](fn func(T) (T, error), opts ...OptFn) Stage[T]
```

NewSimpleStage creates a new stage without next argument.

<a name="NewStage"></a>
### func NewStage

```go
func NewStage[T any](fn StageFn[T], opts ...OptFn) Stage[T]
```

NewStage creates a new stage with the given function and options.

<a name="StageFn"></a>
## type StageFn

StageFn is the function signature for a stage.

```go
type StageFn[T any] func(in T, next func(T) (T, error)) (T, error)
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
